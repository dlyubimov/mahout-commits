#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{fullpage}
\usepackage{multicol,caption}
\usepackage{wrapfig}

\usepackage{amsthm}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{problem}{Problem}
\theoremstyle{remark}
\newtheorem{observation}{Observation}


\usepackage{tikz}
\usetikzlibrary{positioning,shadings,fadings,automata,matrix,shapes,arrows,backgrounds}

\tikzstyle{every picture}=[execute at end picture=
{
\begin{pgfonlayer}{background}
\path[fill=red!10!green!4,rounded corners]
(current bounding box.south west) rectangle
(current bounding box.north east);
\end{pgfonlayer}
}]

\definecolor{tentative}{rgb}{0.4,0.6,0.7}
\definecolor{comment}{rgb}{0.7,0.4,0.4}
\definecolor{Turquoise}{rgb}{0,0.81,0.85}
\definecolor{Violet}{rgb}{0.93,0.5,0.93}
\definecolor{hlhc}{rgb}{0.96,0.75,0.75}
\definecolor{hllc}{rgb}{0.75,0.96,0.75}

\newenvironment{Figure}
  {\par\medskip\noindent\minipage{\linewidth}\centering\vspace{20pt}}
  {\endminipage\par\medskip\vspace{20pt}}

\newbox\mybox

% \renewcommand{\thefootnote}{\fnsymbol{footnote}}

\setlength{\columnseprule}{0.4pt}
\renewcommand\columnseprulecolor{\color{black!10}}
\setlength{\columnsep}{28.0pt}

\usepackage{soul}
\newcommand{\hlhigh}[1]{\sethlcolor{hlhc}\hl{#1}}
\newcommand{\hlmed}[1]{\sethlcolor{yellow}\hl{#1}}
\newcommand{\hllow}[1]{\sethlcolor{hllc}\hl{#1}}

% fancy headers/footers
\usepackage{fancyhdr}
%\setlength{\headheight}{13.6pt}
\pagestyle{fancy}
%\addtolength{\headheight}{\baselineskip}
\setlength{\headsep}{36.0pt}
\setlength{\voffset}{-36.0pt}

\fancyhead[LE,RO]{\vrule\hskip3mm\leftmark}
%\fancyhfoffset[LE,RO]{6mm}
\end_preamble
\use_default_options true
\begin_modules
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 4
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Mahout Scala Bindings 
\begin_inset Newline newline
\end_inset

and
\begin_inset Newline newline
\end_inset

Mahout Spark Bindings
\begin_inset Newline newline
\end_inset

for Linear Algebra Subroutines
\begin_inset Newline newline
\end_inset


\size small
Working Notes and Manual
\end_layout

\begin_layout Author
Dmitriy Lyubimov
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
dlyubimov at apache dot org
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
In recent years significant effort was spent to produce semantically friendly
 environments for linear algebra.
 Working with vector, matrix and tensor data structures as a single data
 type offers essential qualities necessary for rapid prototyping of algebraicall
y defined mathematical problems.
 The other side of the coin is convenience of the same environment as a
 programming language.
 Yet another one is doing things at scale.
 Yet another highly desirable capability of the same environment is plotting
 and visualization.
 Without bringing any detailing review of existing environments here, the
 author however offers an opinion that while a lot of environments succeed
 in one or more of these aspects, however none of them adequately addresses
 all of them at the same time and at reasonable cost.
 
\end_layout

\begin_layout Abstract
Unlike many other environments, Mahout model was targeting both dense and
 sparse data structures from the very beginning both in type modeling and
 cost-based optimized computations.
\end_layout

\begin_layout Abstract
In this work we are trying to bring semantic explicitness to Mahout's in-core
 and out-of-core linear algebra subroutines, while adding benefits of strong
 programming environments of scala, and extending great scalability benefits
 of Spark and GraphX.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Section*
Overview
\end_layout

\begin_layout Standard
The manual is mostly origanised by giving DSL features by example.
 That means that capabilities are wider than those shown, and may change
 behind the scenes as the work develops.
 However, the authors try to facilitate and ecourage particular style given,
 and retain behind-the-scenes compatibility with the examples given.
 
\end_layout

\begin_layout Standard
If a matrix or a vector are denoted by a single Latin letter, I use capital
 letters to denote matrices, and small letters to denote vectors, thus diverging
 somewhat from accepted camel case for reference variables in these few
 cases.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Mahout in-core algebraic Scala Bindings
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
See link: 
\begin_inset CommandInset href
LatexCommand href
name "original proposal."
target "http://weatheringthrutechdays.blogspot.com/2013/07/scala-dsl-for-mahout-in-core-linear.html"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In-core DSL is hardly much more than just a syntactic sugar over 
\family typewriter
org.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset

apa
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset

che.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset

ma
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset

hout.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset

math.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset

Mat
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset

rix
\family default
(
\family typewriter
Vec
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset

tor
\family default
) trait implementations.
 As such, all originally implemented operation signatures of Mahout are
 also retained.
\end_layout

\begin_layout Subsection
Imports
\end_layout

\begin_layout Standard
The following two scala imports are typically used to enable Mahout Scala
 DSL bindings for Linear Algebra:
\end_layout

\begin_layout LyX-Code
import org.apache.mahout.math.scalabindings._
\end_layout

\begin_layout LyX-Code
import RLikeOps._
\end_layout

\begin_layout Standard
Another option is to use 
\begin_inset Quotes eld
\end_inset

matlab like
\begin_inset Quotes erd
\end_inset

 dialect by doing 
\end_layout

\begin_layout LyX-Code
import MatlabLikeOps._
\end_layout

\begin_layout Standard
However, Matlab-like DSL dialect adherence to original Matlab dialect is
 far less optimal that R dialect due to the specifics of operator support
 in scala, so we just will limit ourselves to R-like dialect here.
\end_layout

\begin_layout Subsection
Inline initialization
\end_layout

\begin_layout Standard
Dense vectors 
\end_layout

\begin_layout LyX-Code
val denseVec1: Vector = (1.0, 1.1, 1.2)
\end_layout

\begin_layout LyX-Code
val denseVec2 = dvec(1, 0, 1.1, 1.2)
\end_layout

\begin_layout Standard
Sparse vectors
\end_layout

\begin_layout LyX-Code
val sparseVec = svec((5 -> 1) :: (10 -> 2.0) :: Nil)
\end_layout

\begin_layout LyX-Code
val sparseVec2: Vector = (5 -> 1.0) :: (10 -> 2.0) :: Nil
\end_layout

\begin_layout Standard
matrix inline initialization, either dense or sparse, is always row-wise:
\end_layout

\begin_layout Standard
dense matrices : 
\end_layout

\begin_layout LyX-Code
val A = dense((1, 2, 3), (3, 4, 5))
\end_layout

\begin_layout Standard
sparse matrices 
\end_layout

\begin_layout LyX-Code
val A = sparse(
\end_layout

\begin_deeper
\begin_layout LyX-Code
(1, 3) :: Nil,
\end_layout

\begin_layout LyX-Code
(0, 2) :: (1, 2.5) :: Nil
\end_layout

\end_deeper
\begin_layout LyX-Code
)
\end_layout

\begin_layout Standard
diagonal matrix with constant diagonal elements
\end_layout

\begin_layout LyX-Code
diag(10, 3.5) 
\end_layout

\begin_layout Standard
diagonal matrix with main diagonal backed by a vector 
\end_layout

\begin_layout LyX-Code
diagv((1, 2, 3, 4, 5))
\end_layout

\begin_layout Standard
Identity matrix 
\end_layout

\begin_layout LyX-Code
eye(10)
\end_layout

\begin_layout Standard
Obviously, direct initialization of any vector or matrix type in Mahout
 is still available with regular oeration 
\family typewriter
new
\family default
.
\end_layout

\begin_layout Subsection
Slicing and Assigning
\end_layout

\begin_layout Standard
geting vector element 
\end_layout

\begin_layout LyX-Code
val d = vec(5)
\end_layout

\begin_layout Standard
setting vector element 
\end_layout

\begin_layout LyX-Code
vec(5) = 3.0
\end_layout

\begin_layout Standard
getting matrix element 
\end_layout

\begin_layout LyX-Code
val d = m(3,5)
\end_layout

\begin_layout Standard
setting matrix element (setQuick() behind the scenes) 
\end_layout

\begin_layout LyX-Code
M(3,5) = 3.0
\end_layout

\begin_layout Standard
Getting matrix row or column
\end_layout

\begin_layout LyX-Code
val rowVec = M(3, ::) 
\end_layout

\begin_layout LyX-Code
val colVec = M(::, 3) 
\end_layout

\begin_layout Standard
Setting matrix row or column 
\end_layout

\begin_layout LyX-Code
M(3, ::) = (1, 2, 3)
\end_layout

\begin_layout LyX-Code
M(::, 3) = (1, 2, 3)
\end_layout

\begin_layout Standard
thru vector assignment also works 
\end_layout

\begin_layout LyX-Code
M(3, ::) := (1, 2, 3)
\end_layout

\begin_layout LyX-Code
M(::, 3) := (1, 2, 3)
\end_layout

\begin_layout Standard
subslices of row or vector work too 
\end_layout

\begin_layout LyX-Code
a(0, 0 to 1) = (3, 5)
\end_layout

\begin_layout Standard
or with vector assignment
\end_layout

\begin_layout LyX-Code
a(0, 0 to 1) := (3, 5)
\end_layout

\begin_layout Standard
matrix contiguous block as matrix, with assignment 
\end_layout

\begin_layout LyX-Code
// block
\end_layout

\begin_layout LyX-Code
val B = A(2 to 3, 3 to 4) 
\end_layout

\begin_layout LyX-Code
// asignment to a block
\end_layout

\begin_layout LyX-Code
A(0 to 1, 1 to 2) = dense((3, 2), (2, 3))
\end_layout

\begin_layout Standard
or thru the matrix assignment operator 
\end_layout

\begin_layout LyX-Code
A(0 to 1, 1 to 2) := dense((3, 2), (2, 3))
\end_layout

\begin_layout Standard
Assignment operator by copying between vectors or matrix 
\end_layout

\begin_layout LyX-Code
vec1 := vec2 
\end_layout

\begin_layout LyX-Code
M1 := M2 
\end_layout

\begin_layout Standard
also works for matrix subindexing notations as per above
\end_layout

\begin_layout Standard
Assignment thru a function literal (matrix)
\end_layout

\begin_layout LyX-Code
M := ((row, col, x) => if (row == col) 1 else 0)
\end_layout

\begin_layout Standard
for a vector, the same:
\end_layout

\begin_layout LyX-Code
vec := ((index, x) => sqrt(x))
\end_layout

\begin_layout Subsection
BLAS-like operations
\end_layout

\begin_layout Standard
plus/minus, either vector or matrix or numeric, with assignment or not
\end_layout

\begin_layout LyX-Code
a + b
\end_layout

\begin_layout LyX-Code
a - b
\end_layout

\begin_layout LyX-Code
a + 5.0
\end_layout

\begin_layout LyX-Code
a - 5.0
\end_layout

\begin_layout Standard
Hadamard (elementwise) product, either vector or matrix or numeric operands
\end_layout

\begin_layout LyX-Code
a * b
\end_layout

\begin_layout LyX-Code
a * 5
\end_layout

\begin_layout Standard
same things with assignment, matrix, vector or numeric operands 
\end_layout

\begin_layout LyX-Code
a += b
\end_layout

\begin_layout LyX-Code
a -= b
\end_layout

\begin_layout LyX-Code
a += 5.0
\end_layout

\begin_layout LyX-Code
a -= 5.0 
\end_layout

\begin_layout LyX-Code
a *= b
\end_layout

\begin_layout LyX-Code
a *= 5
\end_layout

\begin_layout Standard
One nuance here is associativity rules in scala.
 E.g.
 
\family typewriter
1/x
\family default
 in R (where x is vector or matrix) is elementwise inverse operation and
 in scala realm would be expressed as
\end_layout

\begin_layout LyX-Code
val xInv = 1 /: x
\end_layout

\begin_layout Standard
and R's 
\family typewriter
5.0 - x
\family default
 would be
\end_layout

\begin_layout LyX-Code
val x1 = 5.0 -: x
\end_layout

\begin_layout Standard
Even trickier and really probably not so obvious stuff :
\end_layout

\begin_layout LyX-Code
a -=: b
\end_layout

\begin_layout Standard
assigns 
\family typewriter
a - b
\family default
 to 
\family typewriter
b
\family default
 (in-place) and returns 
\family typewriter
b
\family default
.
 Similarly for 
\family typewriter
a /=: b
\family default
 or 
\family typewriter
1 /=: v
\family default
.
\end_layout

\begin_layout Standard
(all assignment operations, including :=, return the assignee argument just
 like in C++)
\end_layout

\begin_layout Standard
dot product (vector operands) 
\end_layout

\begin_layout LyX-Code
a dot b 
\end_layout

\begin_layout Standard
matrix /vector equivalency (or non-equivalency).
 Dangerous, exact equivalence is rarely useful, better use norm comparisons
 with admission of small errors 
\end_layout

\begin_layout LyX-Code
a === b
\end_layout

\begin_layout LyX-Code
a !== b
\end_layout

\begin_layout Standard
Matrix multiplication (matrix operands)
\end_layout

\begin_layout LyX-Code
a %*% b
\end_layout

\begin_layout Standard
for matrices that explicitly support optimized right and left muliply (currently
, diagonal matrices)
\end_layout

\begin_layout Standard
right-multiply (for symmetry, in fact same as %*%) 
\end_layout

\begin_layout LyX-Code
diag(5,5) :%*% b 
\end_layout

\begin_layout Standard
optimized left multiply with a diagonal matrix:
\end_layout

\begin_layout LyX-Code
A %*%: diag(5,5) # i.e.
 same as (diag(5,5) :%*% A.t) t
\end_layout

\begin_layout Standard
Second norm, vector or matrix argument:
\end_layout

\begin_layout LyX-Code
a.norm
\end_layout

\begin_layout Standard
Finally, transpose 
\end_layout

\begin_layout LyX-Code
val Mt = M.t
\end_layout

\begin_layout Standard
Note: Transposition currently is handled via 
\emph on
view
\emph default
, i.e.
 updating a transposed matrix will be updating the original.
 Also computing something like 
\begin_inset Formula $\mathbf{X}^{\top}\mathbf{X}$
\end_inset

 
\end_layout

\begin_layout LyX-Code
val XtX = X.t %*% X
\end_layout

\begin_layout Standard
will not therefore incur any additional data copying.
\end_layout

\begin_layout Subsection
Decompositions
\end_layout

\begin_layout Standard
All arguments in the following are matrices.
\end_layout

\begin_layout Paragraph
Cholesky decompositon
\end_layout

\begin_layout Standard
(as an object of a CholeskyDecomposition class with all its operations)
\end_layout

\begin_layout LyX-Code
val ch = chol(M)
\end_layout

\begin_layout Paragraph
SVD
\end_layout

\begin_layout LyX-Code
val (U, V, s) = svd(M)
\end_layout

\begin_layout Paragraph
EigenDecomposition
\end_layout

\begin_layout LyX-Code
val (V, d) = eigen(M)
\end_layout

\begin_layout Paragraph
QR decomposition
\end_layout

\begin_layout LyX-Code
val (Q, R) = qr(M)
\end_layout

\begin_layout Paragraph
Rank
\end_layout

\begin_layout Standard
Check for rank deficiency (runs rank-revealing QR)
\end_layout

\begin_layout LyX-Code
M.isFullRank
\end_layout

\begin_layout Paragraph
In-core SSVD
\end_layout

\begin_layout LyX-Code
val (U, V, s) = ssvd(A, k=50, p=15, q=1)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsection
Misc
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
vector cardinality 
\end_layout

\begin_layout LyX-Code
a.length
\end_layout

\begin_layout Standard
matrix cardinality 
\end_layout

\begin_layout LyX-Code
m.nrow
\end_layout

\begin_layout LyX-Code
m.ncol
\end_layout

\begin_layout Standard
a copy-by-value (vector or matrix ) 
\end_layout

\begin_layout LyX-Code
val b = a cloned 
\end_layout

\begin_layout Subsection
Bringing it all together: in-core SSVD
\end_layout

\begin_layout Standard
Just to illustrate semantic clarity, we will adduce a source for in-core
 SSVD code.
\end_layout

\begin_layout LyX-Code
  /**
\end_layout

\begin_layout LyX-Code
   * In-core SSVD algorithm.
\end_layout

\begin_layout LyX-Code
   *
\end_layout

\begin_layout LyX-Code
   * @param a input matrix A
\end_layout

\begin_layout LyX-Code
   * @param k request SSVD rank
\end_layout

\begin_layout LyX-Code
   * @param p oversampling parameter
\end_layout

\begin_layout LyX-Code
   * @param q number of power iterations
\end_layout

\begin_layout LyX-Code
   * @return (U,V,s)
\end_layout

\begin_layout LyX-Code
   */
\end_layout

\begin_layout LyX-Code
  def ssvd(a: Matrix, k: Int, p: Int = 15, q: Int = 0) = {
\end_layout

\begin_layout LyX-Code
    val m = a.nrow
\end_layout

\begin_layout LyX-Code
    val n = a.ncol
\end_layout

\begin_layout LyX-Code
    if (k > min(m, n))
\end_layout

\begin_layout LyX-Code
      throw new IllegalArgumentException(
\end_layout

\begin_layout LyX-Code
        "k cannot be greater than smaller of m,n")
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
    val pfxed = min(p, min(m, n) - k)
\end_layout

\begin_layout LyX-Code
    // actual decomposition rank
\end_layout

\begin_layout LyX-Code
    val r = k + pfxed
\end_layout

\begin_layout LyX-Code
    val rnd = RandomUtils.getRandom
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
    val omega = Matrices.symmetricUniformView(n, r, rnd.nextInt)
\end_layout

\begin_layout LyX-Code
    var y = a %*% omega
\end_layout

\begin_layout LyX-Code
    var yty = y.t %*% y
\end_layout

\begin_layout LyX-Code
    val at = a.t
\end_layout

\begin_layout LyX-Code
    var ch = chol(yty)
\end_layout

\begin_layout LyX-Code
    var bt = ch.solveRight(at %*% y)
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
    // power iterations
\end_layout

\begin_layout LyX-Code
    for (i <- 0 until q) {
\end_layout

\begin_layout LyX-Code
      y = a %*% bt
\end_layout

\begin_layout LyX-Code
      yty = y.t %*% y
\end_layout

\begin_layout LyX-Code
      ch = chol(yty)
\end_layout

\begin_layout LyX-Code
      bt = ch.solveRight(at %*% y)
\end_layout

\begin_layout LyX-Code
    }
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
    val bbt = bt.t %*% bt
\end_layout

\begin_layout LyX-Code
    val (uhat, d) = eigen(bbt)
\end_layout

\begin_layout LyX-Code
    val s = d.sqrt
\end_layout

\begin_layout LyX-Code
    val u = ch.solveRight(y) %*% uhat
\end_layout

\begin_layout LyX-Code
    val v = bt %*% (uhat %*%: diagv(1 /: s))
\end_layout

\begin_layout LyX-Code
    (u(::, 0 until k), v(::, 0 until k), s(0 until k))
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsection
Pitfalls 
\end_layout

\begin_layout Standard
This one the people who are accustomed to writing R linear algebra will
 probably find quite easy to fall into.
 R has a nice property, a copy-on-write, so all variables actually appear
 to act as no-side-effects scalar-like values and all assignment appear
 to be by value.
 Since scala always assigns by reference (except for AnyVal types which
 are assigned by value), it is easy to fall prey to the following side effect
 modifications
\end_layout

\begin_layout LyX-Code
val m1 = m 
\end_layout

\begin_layout LyX-Code
m1 += 5.0 // modifies m as well
\end_layout

\begin_layout Standard
A fix is as follows: 
\end_layout

\begin_layout LyX-Code
val m1 = m cloned 
\end_layout

\begin_layout LyX-Code
m1 += 5.0 // now m is intact
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Out-of-core linalg bindings
\end_layout

\begin_layout Standard
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
The subject of this section are solely operations applicable to Mahout's
 DRM (distributed row matrix).
 Once loaded into spark, DRM is represented by Spark partitions initially
 consisting of handful of row vectors.
\end_layout

\begin_layout Standard
Here and on, I will denote spark-backed DRM references as 
\family typewriter
A
\family default
, whereas in-core matrices as 
\family typewriter
inCoreA
\family default
.
\end_layout

\begin_layout Subsection
Imports
\end_layout

\begin_layout LyX-Code
org.apache.mahout.sparkbindings._
\end_layout

\begin_layout Subsection
Initializing Mahout/Spark context
\end_layout

\begin_layout Standard
Many (if not all) operations will require a Spark context.
 Spark context can be passed in two ways: (1) as an implicit value; and
 as passed down from a parent source (DRM's backing RDD).
 
\end_layout

\begin_layout Standard
To initialize Mahout/Spark session, just create an implicit value of a specifica
lly prepped Spark context: 
\end_layout

\begin_layout LyX-Code
implicit val mahoutCtx = mahoutSparkContext(
\end_layout

\begin_deeper
\begin_layout LyX-Code
masterUrl = "local", 
\end_layout

\begin_layout LyX-Code
appName = "MahoutLocalContext" 
\end_layout

\begin_layout LyX-Code
// [,...]
\end_layout

\end_deeper
\begin_layout LyX-Code
)
\end_layout

\begin_layout Standard
Parameter 
\family typewriter
masterUrl
\family default
 points to Spark's master.
 Note that Mahout expects either MAHOUT_HOME environment or -Dmahout.home=...
 java system variable to point to Mahout home directory in order to collect
 relevant jars for the Spark sessions.
\end_layout

\begin_layout Standard
From there on, as long as Mahout-initialized Spark context is exposed thru
 implicit variable, attribute or paremeter, there's no need to specify it
 explicitly for any of the successive operations.
 
\end_layout

\begin_layout Standard
Note that as of the time of this writing Spark sessions cannot coexist in
 the same jvm, even though a single spark session is reentrant and can handle
 requests from more than one thread.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsection
DRM Persistence operators
\end_layout

\begin_layout Subsubsection
Loading DRM off HDFS
\end_layout

\begin_layout LyX-Code
val A = drmFromHDFS(path = hdfsPath) 
\end_layout

\begin_layout Subsubsection
Parallelizing from an in-core matrix
\end_layout

\begin_layout LyX-Code
val inCoreA = dense((1, 2, 3), (3, 4, 5))
\end_layout

\begin_layout LyX-Code
val A = drmParallelize(inCoreA)
\end_layout

\begin_layout Subsubsection
Empty DRM
\end_layout

\begin_layout LyX-Code
val A = drmParallelizeEmpty(100, 50)
\end_layout

\begin_layout Subsubsection
Collecting to driver's jvm in-core
\end_layout

\begin_layout LyX-Code
val inCoreA = A.collect()
\end_layout

\begin_layout Subsubsection
Collecting to HDFS
\end_layout

\begin_layout Standard
Collect Spark-backed DRM to HDFS in Mahout's DRM format files:
\end_layout

\begin_layout LyX-Code
A.writeDRM(path = hdfsPath)
\end_layout

\begin_layout Subsection
Logical algebraic operators on DRM matrices
\end_layout

\begin_layout Standard
We will define a logical set of operators that are familiar to users of
 environments such as R, which are elementwise +, -, *, / as well as matrix
 multiplication %*% and transposition.
\end_layout

\begin_layout Standard
Logical operators comprised into expression do not however mean that concrete
 physical plan is materialized until the expression is 
\begin_inset Quotes eld
\end_inset

checkpointed
\begin_inset Quotes erd
\end_inset

 -- directly or indirectly.
 In terms of Spark, this is called 
\begin_inset Quotes eld
\end_inset

action
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
Unlike with Spark, we want to discern two types of 
\begin_inset Quotes eld
\end_inset

actions
\begin_inset Quotes erd
\end_inset

: optimizer action and computational action.
 
\end_layout

\begin_layout Standard
Optimizer action triggers materialization of a physical plan (concrete RDD
 graph with result marked for Spark caching), backed by CheckpointedDRM.
 CheckpointedDRM servies as a cut-off boundary for optmizer action.
 Optimizer action does not trigger actual computation of result data set.
 Right now optimizer action is triggered explicitly by DRMLike#checkpoint().
\end_layout

\begin_layout Standard
On the other hand, computational action leads to result being computed and
 (optionally?) placed into Spark cache.
 Such actions will also lazily and implicitly trigger linalg optimizer checkpoin
ting.
 Currently, computational actions include writeDrm(), collect(), blockify()
 
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\backslash
color{tentative}
\end_layout

\end_inset

and sometimes could also be triggered implicitly by optimizer activity beyond
 current checkpoint cut-off (if checkpointed but not computed and cached
 yet) to run some cost estimates necessary for the optimizer beyond checkpointin
g
, potentially future actions associated with DRM sub-blocking
\lang english

\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
All these rules follow the same patterns as for the in-core arguments.
\end_layout

\begin_layout Subsubsection
Transposition
\end_layout

\begin_layout LyX-Code
A.t
\end_layout

\begin_layout Subsubsection
Elementwise +, -, *, /
\end_layout

\begin_layout Standard
All this operations require identical geometry of operands and row keying
 types that will be asserted at optmizer checkpointing time.
\end_layout

\begin_layout LyX-Code
A + B
\end_layout

\begin_layout LyX-Code
A - B
\end_layout

\begin_layout LyX-Code
A * B
\end_layout

\begin_layout LyX-Code
A / B
\end_layout

\begin_layout Standard
Binary operators involving in-core argument (only on int-keyed DRMs)
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathbf{M}=\mathbf{A}+\mathbf{B}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathbf{M}=\mathbf{A}-\mathbf{B}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathbf{M}=\mathbf{A}\circ\mathbf{B}\,\,\,\mathrm{(Hadamard)}
\]

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathbf{M}=\left(\begin{matrix}\frac{a_{11}}{b_{11}} & \frac{a_{12}}{b_{12}} & \cdots & \frac{a_{1n}}{b_{1n}}\\
\vdots & \vdots & \ddots & \vdots\\
\frac{a_{m1}}{b_{m1}} & \frac{a_{m2}}{b_{m2}} & \cdots & \frac{a_{mn}}{b_{mn}}
\end{matrix}\right)\,\,\,\mathrm{(elementwise\, deletion)}
\]

\end_inset


\end_layout

\begin_layout LyX-Code
A + inCoreB
\end_layout

\begin_layout LyX-Code
A - inCoreB
\end_layout

\begin_layout LyX-Code
A * inCoreB
\end_layout

\begin_layout LyX-Code
A :/ inCoreB
\end_layout

\begin_layout LyX-Code
A :+ inCoreB
\end_layout

\begin_layout LyX-Code
A :- inCoreB
\end_layout

\begin_layout LyX-Code
A :* inCoreB
\end_layout

\begin_layout LyX-Code
A :/ inCoreB
\end_layout

\begin_layout LyX-Code
inCoreA +: B
\end_layout

\begin_layout LyX-Code
inCoreA -: B
\end_layout

\begin_layout LyX-Code
inCoreA *: B
\end_layout

\begin_layout LyX-Code
inCoreA /: B
\end_layout

\begin_layout Standard
Note spark associativity change (e.g.
 inCoreA +: B means B.leftMultiply(A), just like with both in-core arguments).
 Important thing here is that whenever operator arguments include both in-core
 and out-of-core arguments, operator can only be associated with the out-of-core
 argument to support distributed implementation.
\end_layout

\begin_layout Subsubsection
Matrix multiplication 
\family typewriter
%*%
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathbf{M}=\mathbf{A}\mathbf{B}$
\end_inset


\end_layout

\begin_layout LyX-Code
A %*% B
\end_layout

\begin_layout LyX-Code
A %*% inCoreB
\end_layout

\begin_layout LyX-Code
A :%*% inCoreB
\end_layout

\begin_layout LyX-Code
inCoreA %*%: B
\end_layout

\begin_layout Standard
Same as above, when both in-core and out-of-core argumetns used, associativity
 of operation must follow the out-of-core (DRM) argument in the expression.
\end_layout

\begin_layout Subsubsection
Matrix-vector multiplication
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathbf{M}=\mathbf{A}\mathbf{x}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathbf{M}=\mathbf{x}\mathbf{A}
\]

\end_inset


\end_layout

\begin_layout LyX-Code
A %*% x
\end_layout

\begin_layout LyX-Code
A :%*% x
\end_layout

\begin_layout LyX-Code
x %*%: A
\end_layout

\begin_layout Standard
Since vector argument is always in-core, the associativity must follow the
 DRM argument.
\end_layout

\begin_layout Subsubsection
Matrix-real +,-,*,/
\end_layout

\begin_layout Standard
In this context, matrix-scalar operations mean element-wise operatios of
 every matrix element and a scalar.
\end_layout

\begin_layout LyX-Code
A + 5.0
\end_layout

\begin_layout LyX-Code
A :+ 5.0
\end_layout

\begin_layout LyX-Code
5.0 +: A
\end_layout

\begin_layout LyX-Code
A - 5.0
\end_layout

\begin_layout LyX-Code
A :- 5.0
\end_layout

\begin_layout LyX-Code
5.0 -: A  
\end_layout

\begin_layout LyX-Code
A * 5.0
\end_layout

\begin_layout LyX-Code
A :* 5.0
\end_layout

\begin_layout LyX-Code
5.0 *: A
\end_layout

\begin_layout LyX-Code
A / 5.0
\end_layout

\begin_layout LyX-Code
A :/ 5.0
\end_layout

\begin_layout LyX-Code
5.0 /: A
\end_layout

\begin_layout Standard
Note that 
\family typewriter
5.0 -: A
\family default
 means 
\begin_inset Formula $m_{ij}=5-a_{ij}$
\end_inset

 and 
\family typewriter
5.0 /: A
\family default
 means 
\begin_inset Formula $m_{ij}=\frac{5}{a_{ij}}$
\end_inset

 for all elements of the result.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Notations
\end_layout

\begin_layout Standard
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\backslash
color{comment}
\end_layout

\end_inset


\noun on
comment
\noun default

\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\backslash
color{tentative}
\end_layout

\end_inset


\noun on
tentative
\noun default

\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
